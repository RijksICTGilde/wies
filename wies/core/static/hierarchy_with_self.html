<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Selectable Hierarchy with "self-node"</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: #f4f6f8;
        color: #2c3e50;
        padding: 40px 20px;
        min-height: 100vh;
      }

      h1 {
        font-size: 1.4rem;
        font-weight: 600;
        margin-bottom: 24px;
        color: #1a252f;
        letter-spacing: -0.3px;
      }

      #tree-container {
        background: #fff;
        border: 1px solid #dce3ea;
        border-radius: 8px;
        padding: 20px 24px;
        max-width: 800px;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
      }

      ul.tree-level {
        list-style: none;
        padding-left: 0;
      }

      ul.tree-level ul.tree-level {
        padding-left: 28px;
        border-left: 2px solid #e0e4e8;
        margin-left: 12px;
        margin-top: 6px;
        width: 100%;
        flex-basis: 100%;
      }

      li.tree-node {
        padding: 4px 0;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
      }

      li.tree-node > label {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        user-select: none;
        padding: 4px 8px;
        border-radius: 4px;
        transition: background 0.15s ease;
        font-size: 0.9rem;
      }

      li.tree-node > label:hover {
        background: #eef2f7;
      }

      /* Leaf nodes get a spacer to align checkboxes with parent labels */
      li.tree-node:not(.has-children) {
        padding-left: 14px;
      }

      li.tree-node > label input[type="checkbox"] {
        width: 16px;
        height: 16px;
        accent-color: #3b7dd8;
        cursor: pointer;
      }

      /* Fold/expand toggle arrow */
      .toggle {
        display: inline-block;
        width: 14px;
        height: 14px;
        line-height: 14px;
        text-align: center;
        font-size: 10px;
        color: #7f8c8d;
        cursor: pointer;
        user-select: none;
        border-radius: 2px;
        transition:
          transform 0.15s ease,
          color 0.15s ease;
        flex-shrink: 0;
      }

      .toggle:hover {
        color: #2c3e50;
        background: #dce3ea;
      }

      li.tree-node.collapsed > .toggle {
        transform: rotate(-90deg);
      }

      /* Hide children when collapsed */
      li.tree-node.collapsed > ul.tree-level {
        display: none;
      }

      /* Parent nodes are slightly bolder */
      li.tree-node.has-children > label {
        font-weight: 600;
        font-size: 0.92rem;
      }

      /* Leaf nodes */
      li.tree-node:not(.has-children) > label {
        color: #34495e;
      }

      /* Self-referencing nodes (direct onder) */
      li.tree-node.self-node > label {
        font-style: italic;
        color: #6c7a89;
      }

      /* Placement count badge */
      .placement-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 22px;
        height: 18px;
        padding: 0 6px;
        font-size: 0.72rem;
        font-weight: 600;
        font-style: normal;
        line-height: 18px;
        border-radius: 9px;
        background: #e8ecf0;
        color: #5d6d7e;
        flex-shrink: 0;
      }

      li.tree-node.checked > label > .placement-badge {
        background: #d4e8f7;
        color: #2980b9;
      }

      /* Info icon on self-nodes */
      .info-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 16px;
        height: 16px;
        font-size: 11px;
        font-style: normal;
        border-radius: 50%;
        background: #dce3ea;
        color: #5d6d7e;
        cursor: default;
        flex-shrink: 0;
        transition:
          background 0.15s ease,
          color 0.15s ease;
        position: relative;
      }

      .info-icon:hover {
        background: #3b7dd8;
        color: #fff;
      }

      /* Tooltip */
      .info-icon[data-tooltip] {
        cursor: help;
      }

      .info-icon[data-tooltip]::after {
        content: attr(data-tooltip);
        position: absolute;
        left: 50%;
        bottom: calc(100% + 6px);
        transform: translateX(-50%);
        background: #2c3e50;
        color: #fff;
        font-size: 0.78rem;
        font-style: normal;
        line-height: 1.4;
        padding: 6px 10px;
        border-radius: 4px;
        white-space: normal;
        max-width: 500px;
        text-align: left;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        z-index: 10;
      }

      .info-icon[data-tooltip]::before {
        content: "";
        position: absolute;
        left: 50%;
        bottom: calc(100% + 2px);
        transform: translateX(-50%);
        border: 4px solid transparent;
        border-top-color: #2c3e50;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
      }

      .info-icon[data-tooltip]:hover::after,
      .info-icon[data-tooltip]:hover::before {
        opacity: 1;
      }

      /* Checked state highlight */
      li.tree-node.checked > label {
        color: #2980b9;
      }

      /* Layout: tree + selection panel side by side */
      #layout-row {
        display: flex;
        align-items: flex-start;
        gap: 24px;
        flex-wrap: wrap;
      }

      #tree-container {
        flex: 1 1 auto;
      }

      #selection-panel {
        background: #fff;
        border: 1px solid #dce3ea;
        border-radius: 8px;
        padding: 20px 24px;
        min-width: 220px;
        max-width: 320px;
        flex: 0 0 auto;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
      }

      #selection-panel h2 {
        font-size: 0.85rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: #7f8c8d;
        margin-bottom: 12px;
      }

      #selection-list {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      #selection-list li {
        font-size: 0.88rem;
        color: #2980b9;
        padding: 5px 10px;
        border-radius: 4px;
        background: #eef5fc;
        margin-bottom: 6px;
        line-height: 1.3;
      }

      #selection-list .empty-state {
        color: #aab4be;
        font-style: italic;
        background: none;
        padding: 5px 0;
      }
    </style>
  </head>
  <body>
    <h1>Selectable Hierarchy with "self-node"</h1>
    <div id="layout-row">
      <div id="tree-container"></div>
      <div id="selection-panel">
        <h2>Geselecteerd</h2>
        <ul id="selection-list">
          <li class="empty-state">Niets geselecteerd</li>
        </ul>
      </div>
    </div>
    <script>
      // ============================================================
      // HIERARCHY DATA — edit this JSON to change the tree structure
      // ============================================================
      const hierarchyData = {
        label: "Organization",
        nr_of_placements: 25,
        children: [
          {
            label: "Min BZK",
            nr_of_placements: 32,
            children: [
              { label: "Min BZK", self: true, nr_of_placements: 12 },
              {
                label:
                  "Directoraat-generaal Digitalisering en Overheidorganisatie (DGDOO)",
                nr_of_placements: 20,
                children: [
                  {
                    label:
                      "Directoraat-generaal Digitalisering en Overheidorganisatie (DGDOO)",
                    self: true,
                    nr_of_placements: 8,
                  },
                  {
                    label: "Directie Digitale Overheid",
                    nr_of_placements: 12,
                    children: [
                      {
                        label: "Directie Digitale Overheid",
                        self: true,
                        nr_of_placements: 7,
                      },
                      {
                        label: "Afdeling Basisinfrastructuur",
                        nr_of_placements: 5,
                        children: [
                          { label: "Bureau Architectuur", nr_of_placements: 5 },
                        ],
                      },
                    ],
                  },
                  { label: "CIO Rijk", nr_of_placements: 2 },
                ],
              },
            ],
          },
        ],
      };

      // ============================================================
      // TREE RENDERING & CHECKBOX LOGIC
      // ============================================================

      const container = document.getElementById("tree-container");

      /**
       * Build the DOM tree recursively from a data node.
       * Returns the created <ul> element.
       */
      function buildTree(node, parentLabel = "") {
        const ul = document.createElement("ul");
        ul.className = "tree-level";

        const li = document.createElement("li");
        li.className =
          "tree-node" +
          (node.children && node.children.length ? " has-children" : "") +
          (node.self ? " self-node" : "");
        const label = document.createElement("label");

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.addEventListener("change", () =>
          onCheckboxChange(node, li, checkbox),
        );

        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(node.label));

        // Add placement count badge
        if (node.nr_of_placements !== undefined) {
          const badge = document.createElement("span");
          badge.className = "placement-badge";
          badge.textContent = node.nr_of_placements;
          label.appendChild(badge);
        }

        // Add info icon for self-nodes
        if (node.self && parentLabel) {
          const icon = document.createElement("span");
          icon.className = "info-icon";
          icon.textContent = "ℹ";
          icon.setAttribute(
            "data-tooltip",
            "Dit zijn opdrachten die direct onder " +
              parentLabel +
              " vallen en niet onder 1 van de organisatie onderdelen eronder",
          );
          label.appendChild(icon);
        }

        // Add fold/expand arrow BEFORE the label (outside it, so clicks don't toggle checkbox)
        if (node.children && node.children.length) {
          const toggle = document.createElement("span");
          toggle.className = "toggle";
          toggle.textContent = "▼";
          toggle.title = "Toggle";
          toggle.addEventListener("click", () => {
            li.classList.toggle("collapsed");
          });
          li.appendChild(toggle);
        }

        li.appendChild(label);

        // Recursively add children
        if (node.children && node.children.length) {
          const childUl = document.createElement("ul");
          childUl.className = "tree-level";

          for (const child of node.children) {
            const childTree = buildTree(child, node.label);
            childUl.appendChild(childTree.querySelector("li"));
          }

          li.appendChild(childUl);
        }

        ul.appendChild(li);
        return ul;
      }

      /**
       * When a checkbox is toggled:
       * - Cascade DOWN to all descendants
       * - Cascade UP to update ancestor states
       */
      function onCheckboxChange(node, li, checkbox) {
        const checked = checkbox.checked;
        // Cascade down
        cascadeDown(li, checked);
        // Update class
        updateNodeClass(li);
        // Cascade up from this node's parent
        cascadeUp(li);
        // Rebuild the selection list
        rebuildSelectionList();
        // Highlight only the nodes that appear in the selection list
        updateHighlightClasses();
      }

      /**
       * Set all descendant checkboxes to the given state.
       */
      function cascadeDown(li, checked) {
        const descendants = li.querySelectorAll('input[type="checkbox"]');
        descendants.forEach((cb) => {
          cb.checked = checked;
          cb.indeterminate = false;
        });
        // Update classes for all descendant nodes
        li.querySelectorAll("li.tree-node").forEach((descendantLi) => {
          updateNodeClass(descendantLi);
        });
      }

      /**
       * Walk up the tree, updating parent checkboxes based on children state.
       */
      function cascadeUp(startLi) {
        let currentLi = startLi;

        while (currentLi) {
          const parentUl = currentLi.parentElement;
          if (!parentUl) break;
          const parentLi = parentUl.parentElement;
          if (!parentLi || !parentLi.classList.contains("tree-node")) break;

          const parentCheckbox = parentLi.querySelector(
            ":scope > label > input[type='checkbox']",
          );
          if (!parentCheckbox) break;

          // Get direct child checkboxes (one level down)
          const childUl = parentLi.querySelector(":scope > ul.tree-level");
          if (!childUl) break;

          const childCheckboxes = [];
          for (const childLi of childUl.children) {
            const cb = childLi.querySelector(
              ":scope > label > input[type='checkbox']",
            );
            if (cb) childCheckboxes.push(cb);
          }

          const allChecked =
            childCheckboxes.length > 0 &&
            childCheckboxes.every((cb) => cb.checked);
          const someChecked = childCheckboxes.some(
            (cb) => cb.checked || cb.indeterminate,
          );

          if (allChecked) {
            parentCheckbox.checked = true;
            parentCheckbox.indeterminate = false;
          } else if (someChecked) {
            parentCheckbox.checked = false;
            parentCheckbox.indeterminate = true;
          } else {
            parentCheckbox.checked = false;
            parentCheckbox.indeterminate = false;
          }

          updateNodeClass(parentLi);
          currentLi = parentLi;
        }
      }

      /**
       * Update the CSS class on a node based on its checkbox state.
       * (kept for cascadeDown/cascadeUp compatibility, but does nothing visible now)
       */
      function updateNodeClass(li) {
        // highlight is managed by updateHighlightClasses instead
      }

      /**
       * Walk the tree and apply the "checked" highlight class only to
       * the highest checked ancestors — the same nodes that appear
       * in the selection panel.
       */
      function updateHighlightClasses() {
        const rootUl = document.querySelector(
          "#tree-container > ul.tree-level",
        );
        if (rootUl) walkHighlight(rootUl);

        function walkHighlight(parentEl, parentIsChecked = false) {
          const childNodes = parentEl.querySelectorAll(":scope > li.tree-node");
          for (const li of childNodes) {
            const cb = li.querySelector(
              ":scope > label > input[type='checkbox']",
            );
            li.classList.remove("checked");
            if (cb && cb.checked && !parentIsChecked) {
              // This is a top-level checked node — highlight it
              li.classList.add("checked");
              // Recurse to ensure descendants are NOT highlighted (parent covers them)
              const childUl = li.querySelector(":scope > ul.tree-level");
              if (childUl) walkHighlight(childUl, true);
            } else if (!cb || !cb.checked) {
              // Not checked — recurse into children to find checked descendants
              const childUl = li.querySelector(":scope > ul.tree-level");
              if (childUl) walkHighlight(childUl, false);
            }
            // else: cb.checked && parentIsChecked — skip entirely (no highlight, no recurse)
          }
        }
      }

      /**
       * Rebuild the selection panel list.
       * Shows only the highest checked ancestors — if a parent is checked,
       * its descendants are not listed separately.
       */
      function rebuildSelectionList() {
        const list = document.getElementById("selection-list");
        const items = [];

        // Walk the tree top-down; collect checked nodes, skip their subtrees
        function walk(parentEl) {
          const childNodes = parentEl.querySelectorAll(":scope > li.tree-node");
          for (const li of childNodes) {
            const cb = li.querySelector(
              ":scope > label > input[type='checkbox']",
            );
            if (cb && cb.checked) {
              // This node is fully checked — add it, skip descendants
              // Get only the text node(s), not the info-icon glyph
              const labelEl = li.querySelector(":scope > label");
              let labelText = "";
              for (const child of labelEl.childNodes) {
                if (child.nodeType === Node.TEXT_NODE)
                  labelText += child.textContent;
              }
              if (li.classList.contains("self-node"))
                labelText = labelText.trim() + " (direct)";
              items.push(labelText.trim());
            } else {
              // Not checked (or indeterminate) — recurse into children
              const childUl = li.querySelector(":scope > ul.tree-level");
              if (childUl) walk(childUl);
            }
          }
        }

        // Start from the root ul inside #tree-container
        const rootUl = document.querySelector(
          "#tree-container > ul.tree-level",
        );
        if (rootUl) walk(rootUl);

        // Render
        list.innerHTML = "";
        if (items.length === 0) {
          const empty = document.createElement("li");
          empty.className = "empty-state";
          empty.textContent = "Niets geselecteerd";
          list.appendChild(empty);
        } else {
          for (const label of items) {
            const li = document.createElement("li");
            li.textContent = label;
            list.appendChild(li);
          }
        }
      }

      // Render the tree (skip the root node itself, show its children directly)
      const rootUl = document.createElement("ul");
      rootUl.className = "tree-level";

      for (const child of hierarchyData.children) {
        const childTree = buildTree(child);
        rootUl.appendChild(childTree.querySelector("li"));
      }

      container.appendChild(rootUl);
    </script>
  </body>
</html>
